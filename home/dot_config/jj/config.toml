#:schema https://jj-vcs.github.io/jj/latest/config-schema.json

# Jujutsu (jj) Configuration
# Managed by Chezmoi - edit source in dotfiles/home/dot_config/jj/config.toml

# Significantly borrows from @indirect's dotfiles at:
# https://github.com/indirect/dotfiles/blob/8948ae89f70f5c5bf37b35d97afe6430827ea974/private_dot_config/private_jj/config.toml

[user]
name = "Martin Emde"
email = "me@martinemde.com"

[signing]
backend = "ssh"
behavior = "own"
key = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBUOchTXDNe34jfmbmvuPuK4Vi8ClJkbmwkKrULyDh3U"

[git]
abandon-unreachable-commits = true
colocate = true
push-new-bookmarks = true
sign-on-push = true
subprocess = true
write-change-id-header = true

[merge]
# Line-level merge resolution
hunk-level = "line"
# When multiple commits make the same change, accept it automatically
same-change = "accept"

[ui]
bookmark-list-sort-keys = ["committer-date-"]
# Default command when running 'jj' without arguments
default-command = "status"
# Enable colored output
color = "auto"
diff-formatter = ":git"
editor = "nvim"
pager = "delta"
paginate = "auto"
show-cryptographic-signatures = true
diff-editor = ":builtin"

[aliases]
# Convenient shorthands.
fb = ["fuzzy_bookmark"]
ba = ["bookmark", "list", "--all"]
co = ["checkout"]
d = ["diff"]
l = ["log", "-r", "(trunk()..@):: | (trunk()..@)-"]
la = ["log", "-r", "..@"]
ll = ["log", "--template", "builtin_log_detailed"]
rb = ["rebase"]
rebase-all = ["rebase", "-s", "all:roots(trunk()..mutable())", "-d", "trunk()"]
s = ["status"]

fetch = ["git", "fetch"]
name = ["bookmark", "set", "-r", "closest_pushable(@)"]

# Get all open stacks of work.
open = ["log", "-r", "open()"]

# Show the current stack
stack = ["log", "-r", "stack()"]

# Better name, IMO.
credit = ["file", "annotate"]

# Retrunk a series. Typically used as `jj retrunk -s ...`, and notably can be
# used with open:
# - jj retrunk -s 'all:roots(open())'
retrunk = ["rebase", "--destination", "trunk()"]

# Retrunk the current stack of work.
reheat = [
  "rebase",
  "--destination",
  "trunk()",
  "--source",
  "all:roots(trunk()..stack(@))",
]

# Eject content from @ into any other change.
# - jj eject xyz --interactive
eject = ["squash", "--from", "@", "--into"]

# Take content from any change, and move it into @.
# - jj consume xyz path/to/file`
consume = ["squash", "--into", "@", "--from"]

# Bring the closest bookmark up to the closest pushable change
tug = ["util", "exec", "--", "sh", "-c", """
if [ "x$1" = "x" ]; then
  jj bookmark move --from "closest_bookmark(@)" --to "closest_pushable(@)"
else
  jj bookmark move --to "closest_pushable(@)" "$@"
fi
""", ""]

# list or jump to bookmarks
fuzzy_bookmark = [
  "util",
  "exec",
  "--",
  "sh",
  "-c",
  """
if [ "x$1" = "x" ]; then
  jj bookmark list
else
  jj bookmark list -a -T 'separate("@", name, remote) ++ "\n"' 2> /dev/null | sort | uniq | fzf -f "$1" | head -n1 | xargs jj new
fi
""",
  "",
]

# colocate with git and track origin's branches
init = ["util", "exec", "--", "bash", "-c", """
jj git init --colocate
# only track origin branches, not upstream or others
jj bookmark track 'glob:*@origin'
"""]

# track the remote branch and new on top of it
checkout = ["util", "exec", "--", "bash", "-c", """
  jj bookmark track ${@}@origin
  jj new $@
""", ""]

# tug the closest bookmark, push it, and track it
push = [
  "util",
  "exec",
  "--",
  "bash",
  "-c",
  """
tuggable="$(jj log -r 'closest_bookmark(@)..closest_pushable(@)' -T '"n"' --no-graph)"
[[ -n "$tuggable" ]] && jj tug
pushable="$(jj log -r 'remote_bookmarks(remote=origin)..@' -T 'bookmarks' --no-graph)"
[[ -n "$pushable" ]] && jj git push || echo "Nothing to push."
closest="$(jj log -r 'closest_bookmark(@)' -n 1 -T 'bookmarks' --no-graph | cut -d ' ' -f 1)"
closest="${closest%\\*}"
tracked="$(jj bookmark list -r ${closest} -t -T 'if(remote == "origin", name)')"
[[ "$tracked" == "$closest" ]] || jj bookmark track "${closest}@origin"
""",
]

# update from remote and rebase onto the latest
pull = [
  "util",
  "exec",
  "--",
  "bash",
  "-c",
  """
closest="$(jj log -r 'closest_bookmark(@)' -n 1 -T 'bookmarks' --no-graph | cut -d ' ' -f 1)"
closest="${closest%\\*}"
jj git fetch
jj log -n 1 -r "${closest}" 2>&1 > /dev/null && jj rebase -d "${closest}" || jj rebase -d 'trunk()'
jj log -r 'stack()'
""",
]

# create a pull request using `gh` for closest_bookmark(@)
pr = [
  "util",
  "exec",
  "--",
  "bash",
  "-c",
  """
gh pr create --head $(jj log -r 'closest_bookmark(@)' -T 'bookmarks' --no-graph | cut -d ' ' -f 1)
""",
]

# create a pull request from the last change and try to automatically merge it
prl = [
  "util",
  "exec",
  "--",
  "bash",
  "-c",
  """
branch="$(jj log -r 'closest_bookmark(@)' -T 'bookmarks' --no-graph | cut -d ' ' -f 1)"
branch="${branch%\\*}"
title="$(jj log -r $branch -T 'description_title' --no-graph)"
body="$(jj log -r $branch -T 'description_body' --no-graph)"
gh pr create --head "$branch" --title "$title" --body "$body" && gh pr merge $branch --auto --merge
""",
]

[revset-aliases]
'closest_bookmark(to)' = 'heads(::to & bookmarks())'
'closest_pushable(to)' = 'heads(::to & mutable() & ~description(exact:"") & (~empty() | merges()))'

'user(x)' = 'author(x) | committer(x)'

# Private and WIP commits that should never be pushed anywhere.
'wip()' = 'description(glob:"wip:*")'
'private()' = 'description(glob:"private:*")'
'unready()' = 'wip() | private()'

# stack(x, n) is the set of mutable commits reachable from 'x', with 'n'
# parents. 'n' is often useful to customize the display and return set for
# certain operations. 'x' can be used to target the set of 'roots' to traverse,
# e.g. @ is the current stack.
'stack()' = 'ancestors(reachable(@, mutable()), 2)'
'stack(x)' = 'ancestors(reachable(x, mutable()), 2)'
'stack(x, n)' = 'ancestors(reachable(x, mutable()), n)'

# The current set of "open" works. It is defined as:
#
# - given the set of commits not in trunk, that are written by me,
# - calculate the given stack() for each of those commits
#
# n = 1, meaning that nothing from `trunk()` is included, so all resulting
# commits are mutable by definition.
'open()' = 'stack(trunk().. & mine(), 1)'

# the set of 'ready()' commits. defined as the set of open commits, but nothing
# that is blacklisted or any of their children.
'ready()' = 'open() ~ unready()::'

'recent_work' = 'ancestors(visible_heads(), 3) & mutable()'

[colors]
# Used by log node template
"node" = { bold = true }
"node elided" = { fg = "bright black" }
"node working_copy" = { fg = "green" }
"node conflict" = { fg = "red" }
"node immutable" = { fg = "bright cyan" }
"node wip" = { fg = "yellow" }
"node normal" = { bold = false }

[templates]
# I like this symbol ◉ for @, but it's hard to see
log_node = '''
label("node",
  coalesce(
    if(!self, label("elided", "⇋")),
    if(current_working_copy, label("working_copy", "@")),
    if(conflict, label("conflict", "✕")),
    if(immutable, label("immutable", "◆")),
    if(description.starts_with("wip: "), label("wip", "◠")),
    label("normal", "○")
  )
)
'''
